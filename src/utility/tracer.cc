/*
 * Trace Date Executer
 *
 * Trace Data Executer to Simulate the OLAP Environment
 *    (SPC Read-Dominant Workload and Synthetic Workload Generated by DiskSim) 
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <sys/time.h>

#include "../filesystem/filesystem_common.hh"
#include "../filesystem/filesystem_utils.hh"

#include "../gui/report.hh"
#include "../gui/diskusage_report.hh"
#include "../gui/process_report.hh"

#include "../cache/cache.hh"
#include "../cache/no_cache.hh"

#include "../storage/storage.hh"
#include "../storage/blockstorage.hh"

#include "../config/config.hh"

#include "../coding/coding.hh"
#include "../coding/coding_rs.hh"
#include "../coding/coding_jbod.hh"
#include "../coding/coding_mbr.hh"
#include "../coding/coding_raid0.hh"
#include "../coding/coding_raid1.hh"
#include "../coding/coding_raid4.hh"
#include "../coding/coding_raid5.hh"
#include "../coding/coding_raid6.hh"
#include "../coding/coding_src_rs.hh"

#define TRACE_LINE_MAX 100
#define APPLICAION_MAX 10
#define APPLICATION_ID 0 
#define PORT 54321

struct ncfs_state* NCFS_DATA;
FileSystemLayer* fileSystemLayer;
ConfigLayer* configLayer;
CacheLayerBase* cacheLayer;
StorageLayer* storageLayer;
ReportLayer* reportLayer;
DiskusageReport* diskusageLayer;
ProcessReport *processReport;

//failed node id
int _trace_failed_node_id;


/*
 * Trace Task Parameters for Executer
 */
struct trace_task_params{

	//id of the failed node
	int failed_node_id;
};

/*
 * SPC Trace Format
 */
struct SPC_TRACE_FORMAT{

	//application unit
	int asu;

	//logical block address
	int lba;

	//read size
	int size;

	//operation code
	int opcode;

	//time stamp for read request
	double timestamp;

};

/*
 * DiskSim Trace Format
 */
struct DISKSIM_TRACE_FORMAT{

	//request arrival time
	double arrivaltime;

	//device number
	int devicenumber;

	//block number
	int blocknumber;

	//request size
	int requestsize;

	//1:read 0:write
	int requestflags;

};
/*
 * Convert a line in trace file to SPC_TRACE_FORMAT
 * @param trace_line
 *        a line in the trace file
 * @param spc_trace
 *        convert the string line into SPC_TRACE_FORMAT
 */
void convertLineToSPCTraceFormat(char* trace_line, SPC_TRACE_FORMAT* spc_trace){

	char spilt[] = ",";
	char *trace_item = NULL;

	//The First Item: ASU
	trace_item = strtok(trace_line, spilt);
	spc_trace->asu=atoi(trace_item);

	//The Second Item: LBA
	trace_item = strtok(NULL, spilt);
	spc_trace->lba=atoi(trace_item);

	//The Third Item: SIZE
	trace_item = strtok(NULL, spilt);
	spc_trace->size=atoi(trace_item);

	//The Fourth Item: OPCODE
	trace_item = strtok(NULL, spilt);
	if(trace_item[0]=='R'){
		spc_trace->opcode=0; //Read Operation
	}else{
		spc_trace->opcode=1; //Write Operation
	}

	//The Fifth Item: TIMESTAMP
	trace_item = strtok(NULL, spilt);
	spc_trace->timestamp=atof(trace_item);

}

/*
 * Convert a line in trace file to DISKSIM_TRACE_FORMAT
 * @param trace_line
 *        a line in the trace file
 * @param disksim_trace
 *        convert the string line into DISKSIM_TRACE_FORMAT
 */
void convertLineToDiskSimTraceFormat(char* trace_line, DISKSIM_TRACE_FORMAT* disksim_trace){

	char spilt[] = "\t";
	char *trace_item = NULL;

	//The First Item: Request Arrival Time
	trace_item = strtok(trace_line, spilt);
	disksim_trace->arrivaltime=atof(trace_item);

	//The Second Item: Device Number
	trace_item = strtok(NULL, spilt);
	disksim_trace->devicenumber=atoi(trace_item);

	//The Third Item: Block Number
	trace_item = strtok(NULL, spilt);
	disksim_trace->blocknumber=atoi(trace_item);

	//Update Disk Number
	disksim_trace->devicenumber = 3*(disksim_trace->devicenumber) + ((disksim_trace->blocknumber)/2048);

	//Update Block Number
	disksim_trace->blocknumber = ((disksim_trace->blocknumber)%2048);

	//The Fourth Item: Request Size
	trace_item = strtok(NULL, spilt);
	disksim_trace->requestsize=atoi(trace_item);


	/*
	//The Fifth Item: Request Flag
	trace_item = strtok(NULL, spilt);

	int tmp_flag=trace_item[7]-'0';

	if(tmp_flag<0){
	tmp_flag=trace_item[0]-'0';
	}
	 */

	disksim_trace->requestflags=1;

}

/*
 * Print A SPC_TRACE_FORMAT Trace Data
 * @param spc_trace
 *       SPC_TRACE_FORMAT trace data
 */
void printtrace(SPC_TRACE_FORMAT* spc_trace){

	printf("%d\t%d\t%d\t%d\t%f\n",spc_trace->asu,spc_trace->lba,spc_trace->size,
			spc_trace->opcode,spc_trace->timestamp);

}

/*
 * Print A DISKSIM_TRACE_FORMAT Trace Data
 * @param disksim_trace
 *       DISKSIM_TRACE_FORMAT trace data
 */
void printtrace(DISKSIM_TRACE_FORMAT* disksim_trace){

	printf("%f\t%d\t%d\t%d\t%d\n",disksim_trace->arrivaltime,disksim_trace->devicenumber,disksim_trace->blocknumber,
			disksim_trace->requestsize,disksim_trace->requestflags);

}

/*
 * Execute a DISKSIM_TRACE_FORMAT trace data
 * @param disksim_trace
 *       DISKSIM_TRACE_FORMAT trace data
 */
void executeTrace(DISKSIM_TRACE_FORMAT* disksim_trace){

	printtrace(disksim_trace);

	//Now, we only support "r"
	int request_flags=disksim_trace->requestflags;

	//Only Process One Application
	if(request_flags==1){

		//The real block address
		int storage_node_id, read_block_address;

		storage_node_id=disksim_trace->devicenumber;
		read_block_address=disksim_trace->blocknumber;

		//by bytes
		int total_read_size=(NCFS_DATA->disk_block_size) * (disksim_trace->requestsize);

		//timestamp for the request
		//double timeStamp=spc_trace->timestamp;

		char* buf_read = (char*)malloc(sizeof(char)*total_read_size);
		memset(buf_read, 0, total_read_size);

		int tmp_read_size, tmp_read_offset;

		tmp_read_size=0;
		tmp_read_offset=read_block_address*NCFS_DATA->disk_block_size;

		while(total_read_size>=NCFS_DATA->disk_block_size){

			fileSystemLayer->codingLayer->decode(storage_node_id, buf_read+tmp_read_size 
					,NCFS_DATA->disk_block_size, tmp_read_offset+tmp_read_size); 

			tmp_read_size=tmp_read_size+NCFS_DATA->disk_block_size;
			total_read_size=total_read_size-NCFS_DATA->disk_block_size;
		}  

	}

}

/*
 * Execute a SPC_TRACE_FORMAT trace data
 * @param spc_trace
 *       SPC_TRACE_FORMAT trace data
 */
void executeTrace(SPC_TRACE_FORMAT* spc_trace){

	printtrace(spc_trace);

	int application_id=spc_trace->asu;

	//Now, we only support "r"
	int operation_code=spc_trace->opcode;

	int max_block_address=NCFS_DATA->data_disk_num*NCFS_DATA->disk_size[_trace_failed_node_id];

	//int application_id=spc_trace->asu;
	int logical_block_address=spc_trace->lba;
	logical_block_address=logical_block_address%max_block_address;

	//Only Process One Application
	if((application_id==APPLICATION_ID)&&(operation_code==0)&&(logical_block_address<max_block_address)){

		//The real block address
		int storage_node_id, read_block_address;

		storage_node_id=logical_block_address/NCFS_DATA->disk_size[_trace_failed_node_id];
		read_block_address=logical_block_address%NCFS_DATA->disk_size[_trace_failed_node_id];

		//by bytes
		int total_read_size=spc_trace->size;

		//timestamp for the request
		//double timeStamp=spc_trace->timestamp;

		char* buf_read = (char*)malloc(sizeof(char)*total_read_size);
		memset(buf_read, 0, total_read_size);

		int tmp_read_size, tmp_read_offset;

		tmp_read_size=0;
		tmp_read_offset=read_block_address*NCFS_DATA->disk_block_size;

		while(total_read_size>=NCFS_DATA->disk_block_size){

			fileSystemLayer->codingLayer->decode(storage_node_id, buf_read+tmp_read_size 
					,NCFS_DATA->disk_block_size, tmp_read_offset+tmp_read_size); 

			tmp_read_size=tmp_read_size+NCFS_DATA->disk_block_size;
			total_read_size=total_read_size-NCFS_DATA->disk_block_size;
		}


		//read the remaining data
		if(total_read_size>0){

			char* tmp_block = (char*)malloc(sizeof(char)*NCFS_DATA->disk_block_size);

			memset(tmp_block, 0, NCFS_DATA->disk_block_size);

			fileSystemLayer->codingLayer->decode(storage_node_id, tmp_block ,NCFS_DATA->disk_block_size, 
					(tmp_read_offset+tmp_read_size));

			memcpy(buf_read+tmp_read_size,tmp_block,total_read_size);

		}      

	}


}

//Initialize Disk Layer
StorageLayer* initializeStorageLayer(){

	//Currently only use blockstorage
	return new BlockStorage; 
}

CodingLayer* initializeCodingLayer(){

	switch(NCFS_DATA->disk_raid_type){
		case 0: return new Coding4Raid0;break;
		case 1: return new Coding4Raid1;break;
		case 4: return new Coding4Raid4;break;
		case 5: return new Coding4Raid5;break;
		case 6: return new Coding4Raid6();break;	
		case 13: return new Coding4RS();break;	
		case 130: return new Coding4SrcRS();break;
		case 1000: return new Coding4Mbr();break;
	}

	//AbnormalError();
	return NULL;  

}



void* TracerThread_Wait_Notify(void *args){


	struct sockaddr_in executer_addr, scheduler_addr;
	int executer_sd, scheduler_sd;
	int scheduler_addrlen;
	int one = 1;

	/* create socket for repair task executer */	
	if ((executer_sd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		perror("ERROR: cannot create socket\n");
		exit(-1);
	}

	/* set socket option */
	if (setsockopt(executer_sd, SOL_SOCKET, SO_REUSEADDR, (char*)&one, sizeof(one))< 0) {
		perror("ERROR: cannot set socket option\n");
		exit(-1);
	}

	/* prepare the address structure */	
	executer_addr.sin_family = AF_INET;
	executer_addr.sin_port = htons(PORT);
	executer_addr.sin_addr.s_addr = htonl(INADDR_ANY); 

	/* bind the socket to network structure */
	if (bind(executer_sd, (struct sockaddr *)&executer_addr, sizeof(executer_addr)) < 0) {
		perror("Can't bind the socket\n");
		exit(-1);
	}

	/* listen for any pending request */
	if (listen(executer_sd, 100) < 0) {
		perror("Can't listen\n");
		exit(-1);
	}

	printf("Repair Task Executer Is Ready To Work.....\n");

	/* get the size of the client address sturcture */
	scheduler_addrlen = sizeof(scheduler_addr);

	while (1) {

		/* wait for connection from Repair Task Scheduler, scheduler_sd is created for scheduler specially*/
		scheduler_sd = accept(executer_sd, (struct sockaddr *)&scheduler_addr, (socklen_t*) &scheduler_addrlen);

		printf("Repair Task Executer Has Connected With Repair Task Scheduler.\n");

		struct trace_task_params *traceTaskParams;

		//allocate space for encoding_params
		traceTaskParams = (struct trace_task_params *) calloc(sizeof(struct trace_task_params), 1);

		while (1) {

			//receive repair task scheduler repair request
			int len = recv(scheduler_sd, traceTaskParams, sizeof(struct trace_task_params), 0);

			if (len == 0) {
				printf("Connection closed\n");
				close(scheduler_sd);
				return 0;
			} else if (len < 0) {
				perror("ERROR: error in recv\n");
				close(scheduler_sd);
				return 0;
			}

			_trace_failed_node_id=traceTaskParams->failed_node_id;
			printf("Now the failed node is %d\n",traceTaskParams->failed_node_id);

			if(_trace_failed_node_id==21){

				close(scheduler_sd);
				return 0;
			}
		}

	}

	/* Control never goes here */
	return 0;
}




void* TracerThread_Execute_Trace(void *args){

	FILE *file = fopen("synthetic_traces", "r");
	int trace_type = 1;
	_trace_failed_node_id=0;

	struct timeval starttime, endtime;
	double duration;

	if (file!=NULL) {

		//Initialize NCFS 
		struct ncfs_state *ncfs_data;

		ncfs_data = (struct ncfs_state *) calloc(sizeof(struct ncfs_state), 1);
		if (ncfs_data == NULL) {
			perror("main calloc");
			abort();
		}

		//Initialize the fileSystemLayer and configLayer
		fileSystemLayer = new FileSystemLayer();
		configLayer = new ConfigLayer();

		//initialize those variables for ncfs_data
		ncfs_data->no_cache = 0;
		ncfs_data->no_gui = 0;
		ncfs_data->run_experiment = 0;

		ncfs_data->process_state = 0;
		ncfs_data->encoding_time = 0;
		ncfs_data->decoding_time = 0;
		ncfs_data->diskread_time = 0;
		ncfs_data->diskwrite_time = 0;

		ncfs_data->space_list_num = 0;
		ncfs_data->space_list_head = NULL;

		//read the configure file
		fileSystemLayer->readSystemConfig(ncfs_data);

		for (int j=0; j < ncfs_data->disk_total_num; j++){
			ncfs_data->free_offset[j] = (ncfs_data->free_offset[j]) / (ncfs_data->disk_block_size);
			ncfs_data->free_size[j] = (ncfs_data->free_size[j]) / (ncfs_data->disk_block_size);
			ncfs_data->disk_size[j] = (ncfs_data->disk_size[j]) / (ncfs_data->disk_block_size);
		}


		//set the default segment size
		ncfs_data->segment_size = 1;

		fileSystemLayer->get_disk_status(ncfs_data);

		fileSystemLayer->get_operation_mode(ncfs_data);

		for (int j=0; j<ncfs_data->disk_total_num; j++){
			printf("***main: j=%d, dev=%s, free_offset=%d, free_size=%d\n",
					j,ncfs_data->dev_name[j], ncfs_data->free_offset[j],ncfs_data->free_size[j]);
		}

		//initialize gobal objects
		NCFS_DATA = ncfs_data;

		/*Initialize CacheLayer, StorageLayer and CodingLayer*/
		cacheLayer = new NoCache();

		storageLayer = initializeStorageLayer();

		if (NCFS_DATA->no_gui == 0){
			diskusageLayer = new DiskusageReport(100);
			processReport = new ProcessReport();
		}

		fileSystemLayer->codingLayer = initializeCodingLayer();

		//set status of the failed node to be 1 
		fileSystemLayer->set_device_status(_trace_failed_node_id,1);

		//SPC Trace Data
		if(trace_type==0){

			int tmpCount=0;

			struct SPC_TRACE_FORMAT *spc_trace;

			spc_trace = (struct SPC_TRACE_FORMAT *) calloc(sizeof(struct SPC_TRACE_FORMAT), 1);

			char line [TRACE_LINE_MAX];

			double previous_trace_time=0;

			//duration for the next trace
			double timeinterval;

			struct timespec req, rem;

			while (fgets(line, sizeof line, file)!= NULL){

				gettimeofday(&starttime,NULL);

				//Format Trace Data
				convertLineToSPCTraceFormat(line, spc_trace);

				//time interval between two trace data
				timeinterval=spc_trace->timestamp-previous_trace_time;

				req.tv_sec=(int)timeinterval;

				double tv_nsec=timeinterval-((int)timeinterval);

				for(int i=0;i<9;i++){
					tv_nsec=tv_nsec*10;
				}

				req.tv_nsec=(int)tv_nsec;

				if(nanosleep(&req, &rem)<0){

					printf("Error:nanosleep fails.\n");
					return 0;
				}

				//Execute Trace Data
				executeTrace(spc_trace);

				gettimeofday(&endtime,NULL);

				duration = endtime.tv_sec - starttime.tv_sec + (endtime.tv_usec-starttime.tv_usec)/1000000.0;

				printf("Elapsed time = %fs\n",duration);

				previous_trace_time=spc_trace->timestamp;

				tmpCount++;

				if(tmpCount>100)
					return 0;
			}		

			//DiskSim Synthetic Trace Date
		}else if(trace_type==1){

			struct DISKSIM_TRACE_FORMAT *disksim_trace;

			disksim_trace = (struct DISKSIM_TRACE_FORMAT *) calloc(sizeof(struct DISKSIM_TRACE_FORMAT), 1);

			char line [TRACE_LINE_MAX];

			FILE *trace_execute_log_file;

			//record experiment results
			if ((trace_execute_log_file = fopen("TraceExecuteData","a")) != NULL){
				printf("Error: TraceExecuteData Can't Open.\n");
				exit(0);
			}

			int x_temp=0;

			while ((fgets(line, sizeof line, file)!= NULL)&&(_trace_failed_node_id!=21)){

				//Format Trace Data
				convertLineToDiskSimTraceFormat(line, disksim_trace);

				x_temp++;

				//reasonable value
				if(((disksim_trace->blocknumber+disksim_trace->requestsize)<2048)
						&&(disksim_trace->devicenumber!=_trace_failed_node_id)){

					gettimeofday(&starttime,NULL);

					//Execute Trace Data
					executeTrace(disksim_trace);

					gettimeofday(&endtime,NULL);

					duration = endtime.tv_sec - starttime.tv_sec + (endtime.tv_usec-starttime.tv_usec)/1000000.0;

					//Record Experiment Results
					fprintf(trace_execute_log_file,"%d , Read Size = %dB , ", x_temp, (disksim_trace->requestsize)*524288);
					fprintf(trace_execute_log_file,"Storage Node = %d , ", disksim_trace->devicenumber);
					fprintf(trace_execute_log_file,"Elapsed Time = %fs\n", duration);

				}
			}		

		}

		fclose (file);

	}else{

		perror ("Fails");
	}

	return 0; 
}


int main(int argc, char *argv[]){


	pthread_t _ThreadID[2];


	//The First Thread is just for receiving notification
	pthread_create(&(_ThreadID[0]),NULL,TracerThread_Wait_Notify, NULL);



	//The Secoding Thread is just for executer
	pthread_create(&(_ThreadID[1]),NULL,TracerThread_Execute_Trace, NULL);

	/* Main thread now waits for all recovery threads to terminate, before it exits
	   If main block exits, all surviving threads exit, even if the threads have not
	   finished their work */ 

	for(int i=0;i<2;i++){

		pthread_join(_ThreadID[i], NULL);

	}

	return 0;  

}
